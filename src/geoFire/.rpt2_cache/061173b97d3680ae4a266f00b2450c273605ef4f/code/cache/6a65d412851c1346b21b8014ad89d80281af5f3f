{"code":"// Default geohash length\r\nexport var g_GEOHASH_PRECISION = 10;\r\n// Characters used in location geohashes\r\nexport var g_BASE32 = '0123456789bcdefghjkmnpqrstuvwxyz';\r\n// The meridional circumference of the earth in meters\r\nexport var g_EARTH_MERI_CIRCUMFERENCE = 40007860;\r\n// Length of a degree latitude at the equator\r\nexport var g_METERS_PER_DEGREE_LATITUDE = 110574;\r\n// Number of bits per geohash character\r\nexport var g_BITS_PER_CHAR = 5;\r\n// Maximum length of a geohash in bits\r\nexport var g_MAXIMUM_BITS_PRECISION = 22 * g_BITS_PER_CHAR;\r\n// Equatorial radius of the earth in meters\r\nexport var g_EARTH_EQ_RADIUS = 6378137.0;\r\n// The following value assumes a polar radius of\r\n// const g_EARTH_POL_RADIUS = 6356752.3;\r\n// The formulate to calculate g_E2 is\r\n// g_E2 == (g_EARTH_EQ_RADIUS^2-g_EARTH_POL_RADIUS^2)/(g_EARTH_EQ_RADIUS^2)\r\n// The exact value is used here to avoid rounding errors\r\nexport var g_E2 = 0.00669447819799;\r\n// Cutoff for rounding errors on double calculations\r\nexport var g_EPSILON = 1e-12;\r\nMath.log2 = Math.log2 || function (x) {\r\n    return Math.log(x) / Math.log(2);\r\n};\r\n/**\r\n * Validates the inputted key and throws an error if it is invalid.\r\n *\r\n * @param key The key to be verified.\r\n */\r\nexport function validateKey(key) {\r\n    var error;\r\n    if (typeof key !== 'string') {\r\n        error = 'key must be a string';\r\n    }\r\n    else if (key.length === 0) {\r\n        error = 'key cannot be the empty string';\r\n    }\r\n    else if (1 + g_GEOHASH_PRECISION + key.length > 755) {\r\n        // Firebase can only stored child paths up to 768 characters\r\n        // The child path for this key is at the least: 'i/<geohash>key'\r\n        error = 'key is too long to be stored in Firebase';\r\n    }\r\n    else if (/[\\[\\].#$\\/\\u0000-\\u001F\\u007F]/.test(key)) {\r\n        // Firebase does not allow node keys to contain the following characters\r\n        error = 'key cannot contain any of the following characters: . # $ ] [ /';\r\n    }\r\n    if (typeof error !== 'undefined') {\r\n        throw new Error('Invalid GeoFire key \\'' + key + '\\': ' + error);\r\n    }\r\n}\r\n;\r\n/**\r\n * Validates the inputted location and throws an error if it is invalid.\r\n *\r\n * @param location The [latitude, longitude] pair to be verified.\r\n */\r\nexport function validateLocation(location) {\r\n    var error;\r\n    if (!Array.isArray(location)) {\r\n        error = 'location must be an array';\r\n    }\r\n    else if (location.length !== 2) {\r\n        error = 'expected array of length 2, got length ' + location.length;\r\n    }\r\n    else {\r\n        var latitude = location[0];\r\n        var longitude = location[1];\r\n        if (typeof latitude !== 'number' || isNaN(latitude)) {\r\n            error = 'latitude must be a number';\r\n        }\r\n        else if (latitude < -90 || latitude > 90) {\r\n            error = 'latitude must be within the range [-90, 90]';\r\n        }\r\n        else if (typeof longitude !== 'number' || isNaN(longitude)) {\r\n            error = 'longitude must be a number';\r\n        }\r\n        else if (longitude < -180 || longitude > 180) {\r\n            error = 'longitude must be within the range [-180, 180]';\r\n        }\r\n    }\r\n    if (typeof error !== 'undefined') {\r\n        throw new Error('Invalid GeoFire location \\'' + location + '\\': ' + error);\r\n    }\r\n}\r\n;\r\n/**\r\n * Validates the inputted geohash and throws an error if it is invalid.\r\n *\r\n * @param geohash The geohash to be validated.\r\n */\r\nexport function validateGeohash(geohash) {\r\n    var error;\r\n    if (typeof geohash !== 'string') {\r\n        error = 'geohash must be a string';\r\n    }\r\n    else if (geohash.length === 0) {\r\n        error = 'geohash cannot be the empty string';\r\n    }\r\n    else {\r\n        for (var _i = 0, geohash_1 = geohash; _i < geohash_1.length; _i++) {\r\n            var letter = geohash_1[_i];\r\n            if (g_BASE32.indexOf(letter) === -1) {\r\n                error = 'geohash cannot contain \\'' + letter + '\\'';\r\n            }\r\n        }\r\n    }\r\n    if (typeof error !== 'undefined') {\r\n        throw new Error('Invalid GeoFire geohash \\'' + geohash + '\\': ' + error);\r\n    }\r\n}\r\n;\r\n/**\r\n * Validates the inputted query criteria and throws an error if it is invalid.\r\n *\r\n * @param newQueryCriteria The criteria which specifies the query's center and/or radius.\r\n * @param requireCenterAndRadius The criteria which center and radius required.\r\n */\r\nexport function validateCriteria(newQueryCriteria, requireCenterAndRadius) {\r\n    if (requireCenterAndRadius === void 0) { requireCenterAndRadius = false; }\r\n    if (typeof newQueryCriteria !== 'object') {\r\n        throw new Error('query criteria must be an object');\r\n    }\r\n    else if (typeof newQueryCriteria.center === 'undefined' && typeof newQueryCriteria.radius === 'undefined') {\r\n        throw new Error('radius and/or center must be specified');\r\n    }\r\n    else if (requireCenterAndRadius && (typeof newQueryCriteria.center === 'undefined' || typeof newQueryCriteria.radius === 'undefined')) {\r\n        throw new Error('query criteria for a new query must contain both a center and a radius');\r\n    }\r\n    // Throw an error if there are any extraneous attributes\r\n    var keys = Object.keys(newQueryCriteria);\r\n    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\r\n        var key = keys_1[_i];\r\n        if (key !== 'center' && key !== 'radius') {\r\n            throw new Error('Unexpected attribute \\'' + key + '\\' found in query criteria');\r\n        }\r\n    }\r\n    // Validate the 'center' attribute\r\n    if (typeof newQueryCriteria.center !== 'undefined') {\r\n        validateLocation(newQueryCriteria.center);\r\n    }\r\n    // Validate the 'radius' attribute\r\n    if (typeof newQueryCriteria.radius !== 'undefined') {\r\n        if (typeof newQueryCriteria.radius !== 'number' || isNaN(newQueryCriteria.radius)) {\r\n            throw new Error('radius must be a number');\r\n        }\r\n        else if (newQueryCriteria.radius < 0) {\r\n            throw new Error('radius must be greater than or equal to 0');\r\n        }\r\n    }\r\n}\r\n;\r\n/**\r\n * Converts degrees to radians.\r\n *\r\n * @param degrees The number of degrees to be converted to radians.\r\n * @returns The number of radians equal to the inputted number of degrees.\r\n */\r\nexport function degreesToRadians(degrees) {\r\n    if (typeof degrees !== 'number' || isNaN(degrees)) {\r\n        throw new Error('Error: degrees must be a number');\r\n    }\r\n    return (degrees * Math.PI / 180);\r\n}\r\n;\r\n/**\r\n * Generates a geohash of the specified precision/string length from the  [latitude, longitude]\r\n * pair, specified as an array.\r\n *\r\n * @param location The [latitude, longitude] pair to encode into a geohash.\r\n * @param precision The length of the geohash to create. If no precision is specified, the\r\n * global default is used.\r\n * @returns The geohash of the inputted location.\r\n */\r\nexport function encodeGeohash(location, precision) {\r\n    if (precision === void 0) { precision = g_GEOHASH_PRECISION; }\r\n    validateLocation(location);\r\n    if (typeof precision !== 'undefined') {\r\n        if (typeof precision !== 'number' || isNaN(precision)) {\r\n            throw new Error('precision must be a number');\r\n        }\r\n        else if (precision <= 0) {\r\n            throw new Error('precision must be greater than 0');\r\n        }\r\n        else if (precision > 22) {\r\n            throw new Error('precision cannot be greater than 22');\r\n        }\r\n        else if (Math.round(precision) !== precision) {\r\n            throw new Error('precision must be an integer');\r\n        }\r\n    }\r\n    var latitudeRange = {\r\n        min: -90,\r\n        max: 90\r\n    };\r\n    var longitudeRange = {\r\n        min: -180,\r\n        max: 180\r\n    };\r\n    var hash = '';\r\n    var hashVal = 0;\r\n    var bits = 0;\r\n    var even = 1;\r\n    while (hash.length < precision) {\r\n        var val = even ? location[1] : location[0];\r\n        var range = even ? longitudeRange : latitudeRange;\r\n        var mid = (range.min + range.max) / 2;\r\n        if (val > mid) {\r\n            hashVal = (hashVal << 1) + 1;\r\n            range.min = mid;\r\n        }\r\n        else {\r\n            hashVal = (hashVal << 1) + 0;\r\n            range.max = mid;\r\n        }\r\n        even = !even;\r\n        if (bits < 4) {\r\n            bits++;\r\n        }\r\n        else {\r\n            bits = 0;\r\n            hash += g_BASE32[hashVal];\r\n            hashVal = 0;\r\n        }\r\n    }\r\n    return hash;\r\n}\r\n;\r\n/**\r\n * Calculates the number of degrees a given distance is at a given latitude.\r\n *\r\n * @param distance The distance to convert.\r\n * @param latitude The latitude at which to calculate.\r\n * @returns The number of degrees the distance corresponds to.\r\n */\r\nexport function metersToLongitudeDegrees(distance, latitude) {\r\n    var radians = degreesToRadians(latitude);\r\n    var num = Math.cos(radians) * g_EARTH_EQ_RADIUS * Math.PI / 180;\r\n    var denom = 1 / Math.sqrt(1 - g_E2 * Math.sin(radians) * Math.sin(radians));\r\n    var deltaDeg = num * denom;\r\n    if (deltaDeg < g_EPSILON) {\r\n        return distance > 0 ? 360 : 0;\r\n    }\r\n    else {\r\n        return Math.min(360, distance / deltaDeg);\r\n    }\r\n}\r\n;\r\n/**\r\n * Calculates the bits necessary to reach a given resolution, in meters, for the longitude at a\r\n * given latitude.\r\n *\r\n * @param resolution The desired resolution.\r\n * @param latitude The latitude used in the conversion.\r\n * @return The bits necessary to reach a given resolution, in meters.\r\n */\r\nexport function longitudeBitsForResolution(resolution, latitude) {\r\n    var degs = metersToLongitudeDegrees(resolution, latitude);\r\n    return (Math.abs(degs) > 0.000001) ? Math.max(1, Math.log2(360 / degs)) : 1;\r\n}\r\n;\r\n/**\r\n * Calculates the bits necessary to reach a given resolution, in meters, for the latitude.\r\n *\r\n * @param resolution The bits necessary to reach a given resolution, in meters.\r\n * @returns Bits necessary to reach a given resolution, in meters, for the latitude.\r\n */\r\nexport function latitudeBitsForResolution(resolution) {\r\n    return Math.min(Math.log2(g_EARTH_MERI_CIRCUMFERENCE / 2 / resolution), g_MAXIMUM_BITS_PRECISION);\r\n}\r\n;\r\n/**\r\n * Wraps the longitude to [-180,180].\r\n *\r\n * @param longitude The longitude to wrap.\r\n * @returns longitude The resulting longitude.\r\n */\r\nexport function wrapLongitude(longitude) {\r\n    if (longitude <= 180 && longitude >= -180) {\r\n        return longitude;\r\n    }\r\n    var adjusted = longitude + 180;\r\n    if (adjusted > 0) {\r\n        return (adjusted % 360) - 180;\r\n    }\r\n    else {\r\n        return 180 - (-adjusted % 360);\r\n    }\r\n}\r\n;\r\n/**\r\n * Calculates the maximum number of bits of a geohash to get a bounding box that is larger than a\r\n * given size at the given coordinate.\r\n *\r\n * @param coordinate The coordinate as a [latitude, longitude] pair.\r\n * @param size The size of the bounding box.\r\n * @returns The number of bits necessary for the geohash.\r\n */\r\nexport function boundingBoxBits(coordinate, size) {\r\n    var latDeltaDegrees = size / g_METERS_PER_DEGREE_LATITUDE;\r\n    var latitudeNorth = Math.min(90, coordinate[0] + latDeltaDegrees);\r\n    var latitudeSouth = Math.max(-90, coordinate[0] - latDeltaDegrees);\r\n    var bitsLat = Math.floor(latitudeBitsForResolution(size)) * 2;\r\n    var bitsLongNorth = Math.floor(longitudeBitsForResolution(size, latitudeNorth)) * 2 - 1;\r\n    var bitsLongSouth = Math.floor(longitudeBitsForResolution(size, latitudeSouth)) * 2 - 1;\r\n    return Math.min(bitsLat, bitsLongNorth, bitsLongSouth, g_MAXIMUM_BITS_PRECISION);\r\n}\r\n;\r\n/**\r\n * Calculates eight points on the bounding box and the center of a given circle. At least one\r\n * geohash of these nine coordinates, truncated to a precision of at most radius, are guaranteed\r\n * to be prefixes of any geohash that lies within the circle.\r\n *\r\n * @param center The center given as [latitude, longitude].\r\n * @param radius The radius of the circle.\r\n * @returns The eight bounding box points.\r\n */\r\nexport function boundingBoxCoordinates(center, radius) {\r\n    var latDegrees = radius / g_METERS_PER_DEGREE_LATITUDE;\r\n    var latitudeNorth = Math.min(90, center[0] + latDegrees);\r\n    var latitudeSouth = Math.max(-90, center[0] - latDegrees);\r\n    var longDegsNorth = metersToLongitudeDegrees(radius, latitudeNorth);\r\n    var longDegsSouth = metersToLongitudeDegrees(radius, latitudeSouth);\r\n    var longDegs = Math.max(longDegsNorth, longDegsSouth);\r\n    return [\r\n        [center[0], center[1]],\r\n        [center[0], wrapLongitude(center[1] - longDegs)],\r\n        [center[0], wrapLongitude(center[1] + longDegs)],\r\n        [latitudeNorth, center[1]],\r\n        [latitudeNorth, wrapLongitude(center[1] - longDegs)],\r\n        [latitudeNorth, wrapLongitude(center[1] + longDegs)],\r\n        [latitudeSouth, center[1]],\r\n        [latitudeSouth, wrapLongitude(center[1] - longDegs)],\r\n        [latitudeSouth, wrapLongitude(center[1] + longDegs)]\r\n    ];\r\n}\r\n;\r\n/**\r\n * Calculates the bounding box query for a geohash with x bits precision.\r\n *\r\n * @param geohash The geohash whose bounding box query to generate.\r\n * @param bits The number of bits of precision.\r\n * @returns A [start, end] pair of geohashes.\r\n */\r\nexport function geohashQuery(geohash, bits) {\r\n    validateGeohash(geohash);\r\n    var precision = Math.ceil(bits / g_BITS_PER_CHAR);\r\n    if (geohash.length < precision) {\r\n        return [geohash, geohash + '~'];\r\n    }\r\n    geohash = geohash.substring(0, precision);\r\n    var base = geohash.substring(0, geohash.length - 1);\r\n    var lastValue = g_BASE32.indexOf(geohash.charAt(geohash.length - 1));\r\n    var significantBits = bits - (base.length * g_BITS_PER_CHAR);\r\n    var unusedBits = (g_BITS_PER_CHAR - significantBits);\r\n    // delete unused bits\r\n    var startValue = (lastValue >> unusedBits) << unusedBits;\r\n    var endValue = startValue + (1 << unusedBits);\r\n    if (endValue > 31) {\r\n        return [base + g_BASE32[startValue], base + '~'];\r\n    }\r\n    else {\r\n        return [base + g_BASE32[startValue], base + g_BASE32[endValue]];\r\n    }\r\n}\r\n;\r\n/**\r\n * Calculates a set of queries to fully contain a given circle. A query is a [start, end] pair\r\n * where any geohash is guaranteed to be lexiographically larger then start and smaller than end.\r\n *\r\n * @param center The center given as [latitude, longitude] pair.\r\n * @param radius The radius of the circle.\r\n * @return An array of geohashes containing a [start, end] pair.\r\n */\r\nexport function geohashQueries(center, radius) {\r\n    validateLocation(center);\r\n    var queryBits = Math.max(1, boundingBoxBits(center, radius));\r\n    var geohashPrecision = Math.ceil(queryBits / g_BITS_PER_CHAR);\r\n    var coordinates = boundingBoxCoordinates(center, radius);\r\n    var queries = coordinates.map(function (coordinate) {\r\n        return geohashQuery(encodeGeohash(coordinate, geohashPrecision), queryBits);\r\n    });\r\n    // remove duplicates\r\n    return queries.filter(function (query, index) {\r\n        return !queries.some(function (other, otherIndex) {\r\n            return index > otherIndex && query[0] === other[0] && query[1] === other[1];\r\n        });\r\n    });\r\n}\r\n;\r\n/**\r\n * Encodes a location and geohash as a GeoFire object.\r\n *\r\n * @param location The location as [latitude, longitude] pair.\r\n * @param geohash The geohash of the location.\r\n * @returns The location encoded as GeoFire object.\r\n */\r\nexport function encodeGeoFireObject(location, geohash) {\r\n    validateLocation(location);\r\n    validateGeohash(geohash);\r\n    return { '.priority': geohash, 'g': geohash, 'l': location };\r\n}\r\n/**\r\n * Decodes the location given as GeoFire object. Returns null if decoding fails.\r\n *\r\n * @param geoFireObj The location encoded as GeoFire object.\r\n * @returns The location as [latitude, longitude] pair or null if decoding fails.\r\n */\r\nexport function decodeGeoFireObject(geoFireObj) {\r\n    if (geoFireObj && 'l' in geoFireObj && Array.isArray(geoFireObj.l) && geoFireObj.l.length === 2) {\r\n        return geoFireObj.l;\r\n    }\r\n    else {\r\n        throw new Error('Unexpected location object encountered: ' + JSON.stringify(geoFireObj));\r\n    }\r\n}\r\n/**\r\n * Returns the key of a Firebase snapshot across SDK versions.\r\n *\r\n * @param A Firebase snapshot.\r\n * @returns The Firebase snapshot's key.\r\n */\r\nexport function geoFireGetKey(snapshot) {\r\n    var key;\r\n    if (typeof snapshot.key === 'string' || snapshot.key === null) {\r\n        key = snapshot.key;\r\n    }\r\n    else if (typeof snapshot.key === 'function') {\r\n        // @ts-ignore\r\n        key = snapshot.key();\r\n    }\r\n    else {\r\n        // @ts-ignore\r\n        key = snapshot.name();\r\n    }\r\n    return key;\r\n}\r\n/**\r\n * Method which calculates the distance, in kilometers, between two locations,\r\n * via the Haversine formula. Note that this is approximate due to the fact that the\r\n * Earth's radius varies between 6356.752 km and 6378.137 km.\r\n *\r\n * @param location1 The [latitude, longitude] pair of the first location.\r\n * @param location2 The [latitude, longitude] pair of the second location.\r\n * @returns The distance, in kilometers, between the inputted locations.\r\n */\r\nexport function distance(location1, location2) {\r\n    validateLocation(location1);\r\n    validateLocation(location2);\r\n    var radius = 6371; // Earth's radius in kilometers\r\n    var latDelta = degreesToRadians(location2[0] - location1[0]);\r\n    var lonDelta = degreesToRadians(location2[1] - location1[1]);\r\n    var a = (Math.sin(latDelta / 2) * Math.sin(latDelta / 2)) +\r\n        (Math.cos(degreesToRadians(location1[0])) * Math.cos(degreesToRadians(location2[0])) *\r\n            Math.sin(lonDelta / 2) * Math.sin(lonDelta / 2));\r\n    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n    return radius * c;\r\n}\r\n;\r\n","dts":{"name":"/home/laboratoria/Downloads/geofire-js-master/geoFire/geoFireUtils.d.ts","text":"import * as firebase from 'firebase';\r\nimport { GeoFireObj, QueryCriteria } from './interfaces';\r\nexport declare const g_GEOHASH_PRECISION: number;\r\nexport declare const g_BASE32: string;\r\nexport declare const g_EARTH_MERI_CIRCUMFERENCE: number;\r\nexport declare const g_METERS_PER_DEGREE_LATITUDE: number;\r\nexport declare const g_BITS_PER_CHAR: number;\r\nexport declare const g_MAXIMUM_BITS_PRECISION: number;\r\nexport declare const g_EARTH_EQ_RADIUS: number;\r\nexport declare const g_E2: number;\r\nexport declare const g_EPSILON: number;\r\n/**\r\n * Validates the inputted key and throws an error if it is invalid.\r\n *\r\n * @param key The key to be verified.\r\n */\r\nexport declare function validateKey(key: string): void;\r\n/**\r\n * Validates the inputted location and throws an error if it is invalid.\r\n *\r\n * @param location The [latitude, longitude] pair to be verified.\r\n */\r\nexport declare function validateLocation(location: number[]): void;\r\n/**\r\n * Validates the inputted geohash and throws an error if it is invalid.\r\n *\r\n * @param geohash The geohash to be validated.\r\n */\r\nexport declare function validateGeohash(geohash: string): void;\r\n/**\r\n * Validates the inputted query criteria and throws an error if it is invalid.\r\n *\r\n * @param newQueryCriteria The criteria which specifies the query's center and/or radius.\r\n * @param requireCenterAndRadius The criteria which center and radius required.\r\n */\r\nexport declare function validateCriteria(newQueryCriteria: QueryCriteria, requireCenterAndRadius?: boolean): void;\r\n/**\r\n * Converts degrees to radians.\r\n *\r\n * @param degrees The number of degrees to be converted to radians.\r\n * @returns The number of radians equal to the inputted number of degrees.\r\n */\r\nexport declare function degreesToRadians(degrees: number): number;\r\n/**\r\n * Generates a geohash of the specified precision/string length from the  [latitude, longitude]\r\n * pair, specified as an array.\r\n *\r\n * @param location The [latitude, longitude] pair to encode into a geohash.\r\n * @param precision The length of the geohash to create. If no precision is specified, the\r\n * global default is used.\r\n * @returns The geohash of the inputted location.\r\n */\r\nexport declare function encodeGeohash(location: number[], precision?: number): string;\r\n/**\r\n * Calculates the number of degrees a given distance is at a given latitude.\r\n *\r\n * @param distance The distance to convert.\r\n * @param latitude The latitude at which to calculate.\r\n * @returns The number of degrees the distance corresponds to.\r\n */\r\nexport declare function metersToLongitudeDegrees(distance: number, latitude: number): number;\r\n/**\r\n * Calculates the bits necessary to reach a given resolution, in meters, for the longitude at a\r\n * given latitude.\r\n *\r\n * @param resolution The desired resolution.\r\n * @param latitude The latitude used in the conversion.\r\n * @return The bits necessary to reach a given resolution, in meters.\r\n */\r\nexport declare function longitudeBitsForResolution(resolution: number, latitude: number): number;\r\n/**\r\n * Calculates the bits necessary to reach a given resolution, in meters, for the latitude.\r\n *\r\n * @param resolution The bits necessary to reach a given resolution, in meters.\r\n * @returns Bits necessary to reach a given resolution, in meters, for the latitude.\r\n */\r\nexport declare function latitudeBitsForResolution(resolution: number): number;\r\n/**\r\n * Wraps the longitude to [-180,180].\r\n *\r\n * @param longitude The longitude to wrap.\r\n * @returns longitude The resulting longitude.\r\n */\r\nexport declare function wrapLongitude(longitude: number): number;\r\n/**\r\n * Calculates the maximum number of bits of a geohash to get a bounding box that is larger than a\r\n * given size at the given coordinate.\r\n *\r\n * @param coordinate The coordinate as a [latitude, longitude] pair.\r\n * @param size The size of the bounding box.\r\n * @returns The number of bits necessary for the geohash.\r\n */\r\nexport declare function boundingBoxBits(coordinate: number[], size: number): number;\r\n/**\r\n * Calculates eight points on the bounding box and the center of a given circle. At least one\r\n * geohash of these nine coordinates, truncated to a precision of at most radius, are guaranteed\r\n * to be prefixes of any geohash that lies within the circle.\r\n *\r\n * @param center The center given as [latitude, longitude].\r\n * @param radius The radius of the circle.\r\n * @returns The eight bounding box points.\r\n */\r\nexport declare function boundingBoxCoordinates(center: number[], radius: number): number[][];\r\n/**\r\n * Calculates the bounding box query for a geohash with x bits precision.\r\n *\r\n * @param geohash The geohash whose bounding box query to generate.\r\n * @param bits The number of bits of precision.\r\n * @returns A [start, end] pair of geohashes.\r\n */\r\nexport declare function geohashQuery(geohash: string, bits: number): string[];\r\n/**\r\n * Calculates a set of queries to fully contain a given circle. A query is a [start, end] pair\r\n * where any geohash is guaranteed to be lexiographically larger then start and smaller than end.\r\n *\r\n * @param center The center given as [latitude, longitude] pair.\r\n * @param radius The radius of the circle.\r\n * @return An array of geohashes containing a [start, end] pair.\r\n */\r\nexport declare function geohashQueries(center: number[], radius: number): string[][];\r\n/**\r\n * Encodes a location and geohash as a GeoFire object.\r\n *\r\n * @param location The location as [latitude, longitude] pair.\r\n * @param geohash The geohash of the location.\r\n * @returns The location encoded as GeoFire object.\r\n */\r\nexport declare function encodeGeoFireObject(location: number[], geohash: string): GeoFireObj;\r\n/**\r\n * Decodes the location given as GeoFire object. Returns null if decoding fails.\r\n *\r\n * @param geoFireObj The location encoded as GeoFire object.\r\n * @returns The location as [latitude, longitude] pair or null if decoding fails.\r\n */\r\nexport declare function decodeGeoFireObject(geoFireObj: GeoFireObj): number[];\r\n/**\r\n * Returns the key of a Firebase snapshot across SDK versions.\r\n *\r\n * @param A Firebase snapshot.\r\n * @returns The Firebase snapshot's key.\r\n */\r\nexport declare function geoFireGetKey(snapshot: firebase.database.DataSnapshot): string;\r\n/**\r\n * Method which calculates the distance, in kilometers, between two locations,\r\n * via the Haversine formula. Note that this is approximate due to the fact that the\r\n * Earth's radius varies between 6356.752 km and 6378.137 km.\r\n *\r\n * @param location1 The [latitude, longitude] pair of the first location.\r\n * @param location2 The [latitude, longitude] pair of the second location.\r\n * @returns The distance, in kilometers, between the inputted locations.\r\n */\r\nexport declare function distance(location1: number[], location2: number[]): number;\r\n"}}
