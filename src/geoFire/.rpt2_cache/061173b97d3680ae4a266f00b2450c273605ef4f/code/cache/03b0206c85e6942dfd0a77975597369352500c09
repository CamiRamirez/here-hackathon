{"code":"/*!\r\n * GeoFire is an open-source library that allows you to store and query a set\r\n * of keys based on their geographic location. At its heart, GeoFire simply\r\n * stores locations with string keys. Its main benefit, however, is the\r\n * possibility of retrieving only those keys within a given geographic area -\r\n * all in realtime.\r\n *\r\n * GeoFire 0.0.0\r\n * https://github.com/firebase/geofire-js/\r\n * License: MIT\r\n */\r\nimport { GeoQuery } from './geoQuery';\r\nimport { decodeGeoFireObject, distance, encodeGeoFireObject, encodeGeohash, validateLocation, validateKey } from './geoFireUtils';\r\n/**\r\n * Creates a GeoFire instance.\r\n */\r\nvar GeoFire = /** @class */ (function () {\r\n    /**\r\n     * @param _firebaseRef A Firebase reference where the GeoFire data will be stored.\r\n     */\r\n    function GeoFire(_firebaseRef) {\r\n        this._firebaseRef = _firebaseRef;\r\n        if (Object.prototype.toString.call(this._firebaseRef) !== '[object Object]') {\r\n            throw new Error('firebaseRef must be an instance of Firebase');\r\n        }\r\n    }\r\n    /********************/\r\n    /*  PUBLIC METHODS  */\r\n    /********************/\r\n    /**\r\n     * Returns a promise fulfilled with the location corresponding to the provided key.\r\n     *\r\n     * If the provided key does not exist, the returned promise is fulfilled with null.\r\n     *\r\n     * @param key The key of the location to retrieve.\r\n     * @returns A promise that is fulfilled with the location of the given key.\r\n     */\r\n    GeoFire.prototype.get = function (key) {\r\n        validateKey(key);\r\n        return this._firebaseRef.child(key).once('value').then(function (dataSnapshot) {\r\n            var snapshotVal = dataSnapshot.val();\r\n            if (snapshotVal === null) {\r\n                return null;\r\n            }\r\n            else {\r\n                return decodeGeoFireObject(snapshotVal);\r\n            }\r\n        });\r\n    };\r\n    ;\r\n    /**\r\n     * Returns the Firebase instance used to create this GeoFire instance.\r\n     *\r\n     * @returns The Firebase instance used to create this GeoFire instance.\r\n     */\r\n    GeoFire.prototype.ref = function () {\r\n        return this._firebaseRef;\r\n    };\r\n    ;\r\n    /**\r\n     * Removes the provided key from this GeoFire. Returns an empty promise fulfilled when the key has been removed.\r\n     *\r\n     * If the provided key is not in this GeoFire, the promise will still successfully resolve.\r\n     *\r\n     * @param key The key of the location to remove.\r\n     * @returns A promise that is fulfilled after the inputted key is removed.\r\n     */\r\n    GeoFire.prototype.remove = function (key) {\r\n        return this.set(key, null);\r\n    };\r\n    ;\r\n    /**\r\n     * Adds the provided key - location pair(s) to Firebase. Returns an empty promise which is fulfilled when the write is complete.\r\n     *\r\n     * If any provided key already exists in this GeoFire, it will be overwritten with the new location value.\r\n     *\r\n     * @param keyOrLocations The key representing the location to add or a mapping of key - location pairs which\r\n     * represent the locations to add.\r\n     * @param location The [latitude, longitude] pair to add.\r\n     * @returns A promise that is fulfilled when the write is complete.\r\n     */\r\n    GeoFire.prototype.set = function (keyOrLocations, location) {\r\n        var locations;\r\n        if (typeof keyOrLocations === 'string' && keyOrLocations.length !== 0) {\r\n            // If this is a set for a single location, convert it into a object\r\n            locations = {};\r\n            locations[keyOrLocations] = location;\r\n        }\r\n        else if (typeof keyOrLocations === 'object') {\r\n            if (typeof location !== 'undefined') {\r\n                throw new Error('The location argument should not be used if you pass an object to set().');\r\n            }\r\n            locations = keyOrLocations;\r\n        }\r\n        else {\r\n            throw new Error('keyOrLocations must be a string or a mapping of key - location pairs.');\r\n        }\r\n        var newData = {};\r\n        Object.keys(locations).forEach(function (key) {\r\n            validateKey(key);\r\n            var location = locations[key];\r\n            if (location === null) {\r\n                // Setting location to null is valid since it will remove the key\r\n                newData[key] = null;\r\n            }\r\n            else {\r\n                validateLocation(location);\r\n                var geohash = encodeGeohash(location);\r\n                newData[key] = encodeGeoFireObject(location, geohash);\r\n            }\r\n        });\r\n        return this._firebaseRef.update(newData);\r\n    };\r\n    ;\r\n    /**\r\n     * Returns a new GeoQuery instance with the provided queryCriteria.\r\n     *\r\n     * @param queryCriteria The criteria which specifies the GeoQuery's center and radius.\r\n     * @return A new GeoQuery object.\r\n     */\r\n    GeoFire.prototype.query = function (queryCriteria) {\r\n        return new GeoQuery(this._firebaseRef, queryCriteria);\r\n    };\r\n    ;\r\n    /********************/\r\n    /*  STATIC METHODS  */\r\n    /********************/\r\n    /**\r\n     * Static method which calculates the distance, in kilometers, between two locations,\r\n     * via the Haversine formula. Note that this is approximate due to the fact that the\r\n     * Earth's radius varies between 6356.752 km and 6378.137 km.\r\n     *\r\n     * @param location1 The [latitude, longitude] pair of the first location.\r\n     * @param location2 The [latitude, longitude] pair of the second location.\r\n     * @returns The distance, in kilometers, between the inputted locations.\r\n     */\r\n    GeoFire.distance = function (location1, location2) {\r\n        return distance(location1, location2);\r\n    };\r\n    ;\r\n    return GeoFire;\r\n}());\r\nexport { GeoFire };\r\n","dts":{"name":"/home/laboratoria/Downloads/geofire-js-master/geoFire/index.d.ts","text":"/*!\r\n * GeoFire is an open-source library that allows you to store and query a set\r\n * of keys based on their geographic location. At its heart, GeoFire simply\r\n * stores locations with string keys. Its main benefit, however, is the\r\n * possibility of retrieving only those keys within a given geographic area -\r\n * all in realtime.\r\n *\r\n * GeoFire 0.0.0\r\n * https://github.com/firebase/geofire-js/\r\n * License: MIT\r\n */\r\nimport * as firebase from 'firebase';\r\nimport { GeoQuery } from './geoQuery';\r\nimport { QueryCriteria } from './interfaces';\r\n/**\r\n * Creates a GeoFire instance.\r\n */\r\nexport declare class GeoFire {\r\n    private _firebaseRef;\r\n    /**\r\n     * @param _firebaseRef A Firebase reference where the GeoFire data will be stored.\r\n     */\r\n    constructor(_firebaseRef: firebase.database.Reference);\r\n    /********************/\r\n    /********************/\r\n    /**\r\n     * Returns a promise fulfilled with the location corresponding to the provided key.\r\n     *\r\n     * If the provided key does not exist, the returned promise is fulfilled with null.\r\n     *\r\n     * @param key The key of the location to retrieve.\r\n     * @returns A promise that is fulfilled with the location of the given key.\r\n     */\r\n    get(key: string): Promise<number[]>;\r\n    /**\r\n     * Returns the Firebase instance used to create this GeoFire instance.\r\n     *\r\n     * @returns The Firebase instance used to create this GeoFire instance.\r\n     */\r\n    ref(): firebase.database.Reference;\r\n    /**\r\n     * Removes the provided key from this GeoFire. Returns an empty promise fulfilled when the key has been removed.\r\n     *\r\n     * If the provided key is not in this GeoFire, the promise will still successfully resolve.\r\n     *\r\n     * @param key The key of the location to remove.\r\n     * @returns A promise that is fulfilled after the inputted key is removed.\r\n     */\r\n    remove(key: string): Promise<string>;\r\n    /**\r\n     * Adds the provided key - location pair(s) to Firebase. Returns an empty promise which is fulfilled when the write is complete.\r\n     *\r\n     * If any provided key already exists in this GeoFire, it will be overwritten with the new location value.\r\n     *\r\n     * @param keyOrLocations The key representing the location to add or a mapping of key - location pairs which\r\n     * represent the locations to add.\r\n     * @param location The [latitude, longitude] pair to add.\r\n     * @returns A promise that is fulfilled when the write is complete.\r\n     */\r\n    set(keyOrLocations: string | any, location?: number[]): Promise<any>;\r\n    /**\r\n     * Returns a new GeoQuery instance with the provided queryCriteria.\r\n     *\r\n     * @param queryCriteria The criteria which specifies the GeoQuery's center and radius.\r\n     * @return A new GeoQuery object.\r\n     */\r\n    query(queryCriteria: QueryCriteria): GeoQuery;\r\n    /********************/\r\n    /********************/\r\n    /**\r\n     * Static method which calculates the distance, in kilometers, between two locations,\r\n     * via the Haversine formula. Note that this is approximate due to the fact that the\r\n     * Earth's radius varies between 6356.752 km and 6378.137 km.\r\n     *\r\n     * @param location1 The [latitude, longitude] pair of the first location.\r\n     * @param location2 The [latitude, longitude] pair of the second location.\r\n     * @returns The distance, in kilometers, between the inputted locations.\r\n     */\r\n    static distance(location1: number[], location2: number[]): number;\r\n}\r\n"}}
