{"code":"import { GeoCallbackRegistration } from './geoCallbackRegistration';\r\nimport { decodeGeoFireObject, distance, encodeGeohash, geoFireGetKey, geohashQueries, validateCriteria, validateLocation } from './geoFireUtils';\r\n/**\r\n * Creates a GeoQuery instance.\r\n */\r\nvar GeoQuery = /** @class */ (function () {\r\n    /**\r\n     * @param _firebaseRef A Firebase reference where the GeoFire data will be stored.\r\n     * @param queryCriteria The criteria which specifies the query's center and radius.\r\n     */\r\n    function GeoQuery(_firebaseRef, queryCriteria) {\r\n        var _this = this;\r\n        this._firebaseRef = _firebaseRef;\r\n        // Event callbacks\r\n        this._callbacks = { ready: [], key_entered: [], key_exited: [], key_moved: [] };\r\n        // Variable to track when the query is cancelled\r\n        this._cancelled = false;\r\n        // A dictionary of geohash queries which currently have an active callbacks\r\n        this._currentGeohashesQueried = {};\r\n        // A dictionary of locations that a currently active in the queries\r\n        // Note that not all of these are currently within this query\r\n        this._locationsTracked = {};\r\n        // Variables used to keep track of when to fire the 'ready' event\r\n        this._valueEventFired = false;\r\n        this._geohashCleanupScheduled = false;\r\n        this._cleanUpCurrentGeohashesQueriedTimeout = null;\r\n        // Firebase reference of the GeoFire which created this query\r\n        if (Object.prototype.toString.call(this._firebaseRef) !== '[object Object]') {\r\n            throw new Error('firebaseRef must be an instance of Firebase');\r\n        }\r\n        // Every ten seconds, clean up the geohashes we are currently querying for. We keep these around\r\n        // for a little while since it's likely that they will need to be re-queried shortly after they\r\n        // move outside of the query's bounding box.\r\n        this._cleanUpCurrentGeohashesQueriedInterval = setInterval(function () {\r\n            if (_this._geohashCleanupScheduled === false) {\r\n                _this._cleanUpCurrentGeohashesQueried();\r\n            }\r\n        }, 10000);\r\n        // Validate and save the query criteria\r\n        validateCriteria(queryCriteria, true);\r\n        this._center = queryCriteria.center;\r\n        this._radius = queryCriteria.radius;\r\n        // Listen for new geohashes being added around this query and fire the appropriate events\r\n        this._listenForNewGeohashes();\r\n    }\r\n    /********************/\r\n    /*  PUBLIC METHODS  */\r\n    /********************/\r\n    /**\r\n     * Terminates this query so that it no longer sends location updates. All callbacks attached to this\r\n     * query via on() will be cancelled. This query can no longer be used in the future.\r\n     */\r\n    GeoQuery.prototype.cancel = function () {\r\n        var _this = this;\r\n        // Mark this query as cancelled\r\n        this._cancelled = true;\r\n        // Cancel all callbacks in this query's callback list\r\n        this._callbacks = { ready: [], key_entered: [], key_exited: [], key_moved: [] };\r\n        // Turn off all Firebase listeners for the current geohashes being queried\r\n        var keys = Object.keys(this._currentGeohashesQueried);\r\n        keys.forEach(function (geohashQueryStr) {\r\n            var query = _this._stringToQuery(geohashQueryStr);\r\n            _this._cancelGeohashQuery(query, _this._currentGeohashesQueried[geohashQueryStr]);\r\n            delete _this._currentGeohashesQueried[geohashQueryStr];\r\n        });\r\n        // Delete any stored locations\r\n        this._locationsTracked = {};\r\n        // Turn off the current geohashes queried clean up interval\r\n        clearInterval(this._cleanUpCurrentGeohashesQueriedInterval);\r\n    };\r\n    ;\r\n    /**\r\n     * Returns the location signifying the center of this query.\r\n     *\r\n     * @returns The [latitude, longitude] pair signifying the center of this query.\r\n     */\r\n    GeoQuery.prototype.center = function () {\r\n        return this._center;\r\n    };\r\n    ;\r\n    /**\r\n     * Attaches a callback to this query which will be run when the provided eventType fires. Valid eventType\r\n     * values are 'ready', 'key_entered', 'key_exited', and 'key_moved'. The ready event callback is passed no\r\n     * parameters. All other callbacks will be passed three parameters: (1) the location's key, (2) the location's\r\n     * [latitude, longitude] pair, and (3) the distance, in kilometers, from the location to this query's center\r\n     *\r\n     * 'ready' is used to signify that this query has loaded its initial state and is up-to-date with its corresponding\r\n     * GeoFire instance. 'ready' fires when this query has loaded all of the initial data from GeoFire and fired all\r\n     * other events for that data. It also fires every time updateCriteria() is called, after all other events have\r\n     * fired for the updated query.\r\n     *\r\n     * 'key_entered' fires when a key enters this query. This can happen when a key moves from a location outside of\r\n     * this query to one inside of it or when a key is written to GeoFire for the first time and it falls within\r\n     * this query.\r\n     *\r\n     * 'key_exited' fires when a key moves from a location inside of this query to one outside of it. If the key was\r\n     * entirely removed from GeoFire, both the location and distance passed to the callback will be null.\r\n     *\r\n     * 'key_moved' fires when a key which is already in this query moves to another location inside of it.\r\n     *\r\n     * Returns a GeoCallbackRegistration which can be used to cancel the callback. You can add as many callbacks\r\n     * as you would like for the same eventType by repeatedly calling on(). Each one will get called when its\r\n     * corresponding eventType fires. Each callback must be cancelled individually.\r\n     *\r\n     * @param eventType The event type for which to attach the callback. One of 'ready', 'key_entered',\r\n     * 'key_exited', or 'key_moved'.\r\n     * @param callback Callback function to be called when an event of type eventType fires.\r\n     * @returns A callback registration which can be used to cancel the provided callback.\r\n     */\r\n    GeoQuery.prototype.on = function (eventType, callback) {\r\n        var _this = this;\r\n        // Validate the inputs\r\n        if (['ready', 'key_entered', 'key_exited', 'key_moved'].indexOf(eventType) === -1) {\r\n            throw new Error('event type must be \\'ready\\', \\'key_entered\\', \\'key_exited\\', or \\'key_moved\\'');\r\n        }\r\n        if (typeof callback !== 'function') {\r\n            throw new Error('callback must be a function');\r\n        }\r\n        // Add the callback to this query's callbacks list\r\n        this._callbacks[eventType].push(callback);\r\n        // If this is a 'key_entered' callback, fire it for every location already within this query\r\n        if (eventType === 'key_entered') {\r\n            var keys = Object.keys(this._locationsTracked);\r\n            keys.forEach(function (key) {\r\n                var locationDict = _this._locationsTracked[key];\r\n                if (typeof locationDict !== 'undefined' && locationDict.isInQuery) {\r\n                    callback(key, locationDict.location, locationDict.distanceFromCenter);\r\n                }\r\n            });\r\n        }\r\n        // If this is a 'ready' callback, fire it if this query is already ready\r\n        if (eventType === 'ready' && this._valueEventFired) {\r\n            callback();\r\n        }\r\n        // Return an event registration which can be used to cancel the callback\r\n        return new GeoCallbackRegistration(function () {\r\n            _this._callbacks[eventType].splice(_this._callbacks[eventType].indexOf(callback), 1);\r\n        });\r\n    };\r\n    ;\r\n    /**\r\n     * Returns the radius of this query, in kilometers.\r\n     *\r\n     * @returns The radius of this query, in kilometers.\r\n     */\r\n    GeoQuery.prototype.radius = function () {\r\n        return this._radius;\r\n    };\r\n    ;\r\n    /**\r\n     * Updates the criteria for this query.\r\n     *\r\n     * @param newQueryCriteria The criteria which specifies the query's center and radius.\r\n     */\r\n    GeoQuery.prototype.updateCriteria = function (newQueryCriteria) {\r\n        // Validate and save the new query criteria\r\n        validateCriteria(newQueryCriteria);\r\n        this._center = newQueryCriteria.center || this._center;\r\n        this._radius = newQueryCriteria.radius || this._radius;\r\n        // Loop through all of the locations in the query, update their distance from the center of the\r\n        // query, and fire any appropriate events\r\n        var keys = Object.keys(this._locationsTracked);\r\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\r\n            var key = keys_1[_i];\r\n            // If the query was cancelled while going through this loop, stop updating locations and stop\r\n            // firing events\r\n            if (this._cancelled === true) {\r\n                break;\r\n            }\r\n            // Get the cached information for this location\r\n            var locationDict = this._locationsTracked[key];\r\n            // Save if the location was already in the query\r\n            var wasAlreadyInQuery = locationDict.isInQuery;\r\n            // Update the location's distance to the new query center\r\n            locationDict.distanceFromCenter = distance(locationDict.location, this._center);\r\n            // Determine if the location is now in this query\r\n            locationDict.isInQuery = (locationDict.distanceFromCenter <= this._radius);\r\n            // If the location just left the query, fire the 'key_exited' callbacks\r\n            // Else if the location just entered the query, fire the 'key_entered' callbacks\r\n            if (wasAlreadyInQuery && !locationDict.isInQuery) {\r\n                this._fireCallbacksForKey('key_exited', key, locationDict.location, locationDict.distanceFromCenter);\r\n            }\r\n            else if (!wasAlreadyInQuery && locationDict.isInQuery) {\r\n                this._fireCallbacksForKey('key_entered', key, locationDict.location, locationDict.distanceFromCenter);\r\n            }\r\n        }\r\n        // Reset the variables which control when the 'ready' event fires\r\n        this._valueEventFired = false;\r\n        // Listen for new geohashes being added to GeoFire and fire the appropriate events\r\n        this._listenForNewGeohashes();\r\n    };\r\n    ;\r\n    /*********************/\r\n    /*  PRIVATE METHODS  */\r\n    /*********************/\r\n    /**\r\n     * Turns off all callbacks for the provide geohash query.\r\n     *\r\n     * @param query The geohash query.\r\n     * @param queryState An object storing the current state of the query.\r\n     */\r\n    GeoQuery.prototype._cancelGeohashQuery = function (query, queryState) {\r\n        var queryRef = this._firebaseRef.orderByChild('g').startAt(query[0]).endAt(query[1]);\r\n        queryRef.off('child_added', queryState.childAddedCallback);\r\n        queryRef.off('child_removed', queryState.childRemovedCallback);\r\n        queryRef.off('child_changed', queryState.childChangedCallback);\r\n        queryRef.off('value', queryState.valueCallback);\r\n    };\r\n    /**\r\n     * Callback for child added events.\r\n     *\r\n     * @param locationDataSnapshot A snapshot of the data stored for this location.\r\n     */\r\n    GeoQuery.prototype._childAddedCallback = function (locationDataSnapshot) {\r\n        this._updateLocation(geoFireGetKey(locationDataSnapshot), decodeGeoFireObject(locationDataSnapshot.val()));\r\n    };\r\n    /**\r\n     * Callback for child changed events\r\n     *\r\n     * @param locationDataSnapshot A snapshot of the data stored for this location.\r\n     */\r\n    GeoQuery.prototype._childChangedCallback = function (locationDataSnapshot) {\r\n        this._updateLocation(geoFireGetKey(locationDataSnapshot), decodeGeoFireObject(locationDataSnapshot.val()));\r\n    };\r\n    /**\r\n     * Callback for child removed events\r\n     *\r\n     * @param locationDataSnapshot A snapshot of the data stored for this location.\r\n     */\r\n    GeoQuery.prototype._childRemovedCallback = function (locationDataSnapshot) {\r\n        var _this = this;\r\n        var key = geoFireGetKey(locationDataSnapshot);\r\n        if (key in this._locationsTracked) {\r\n            this._firebaseRef.child(key).once('value', function (snapshot) {\r\n                var location = (snapshot.val() === null) ? null : decodeGeoFireObject(snapshot.val());\r\n                var geohash = (location !== null) ? encodeGeohash(location) : null;\r\n                // Only notify observers if key is not part of any other geohash query or this actually might not be\r\n                // a key exited event, but a key moved or entered event. These events will be triggered by updates\r\n                // to a different query\r\n                if (!_this._geohashInSomeQuery(geohash)) {\r\n                    _this._removeLocation(key, location);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Removes unnecessary Firebase queries which are currently being queried.\r\n     */\r\n    GeoQuery.prototype._cleanUpCurrentGeohashesQueried = function () {\r\n        var _this = this;\r\n        var keys = Object.keys(this._currentGeohashesQueried);\r\n        keys.forEach(function (geohashQueryStr) {\r\n            var queryState = _this._currentGeohashesQueried[geohashQueryStr];\r\n            if (queryState.active === false) {\r\n                var query = _this._stringToQuery(geohashQueryStr);\r\n                // Delete the geohash since it should no longer be queried\r\n                _this._cancelGeohashQuery(query, queryState);\r\n                delete _this._currentGeohashesQueried[geohashQueryStr];\r\n            }\r\n        });\r\n        // Delete each location which should no longer be queried\r\n        keys = Object.keys(this._locationsTracked);\r\n        keys.forEach(function (key) {\r\n            if (!_this._geohashInSomeQuery(_this._locationsTracked[key].geohash)) {\r\n                if (_this._locationsTracked[key].isInQuery) {\r\n                    throw new Error('Internal State error, trying to remove location that is still in query');\r\n                }\r\n                delete _this._locationsTracked[key];\r\n            }\r\n        });\r\n        // Specify that this is done cleaning up the current geohashes queried\r\n        this._geohashCleanupScheduled = false;\r\n        // Cancel any outstanding scheduled cleanup\r\n        if (this._cleanUpCurrentGeohashesQueriedTimeout !== null) {\r\n            clearTimeout(this._cleanUpCurrentGeohashesQueriedTimeout);\r\n            this._cleanUpCurrentGeohashesQueriedTimeout = null;\r\n        }\r\n    };\r\n    /**\r\n     * Fires each callback for the provided eventType, passing it provided key's data.\r\n     *\r\n     * @param eventType The event type whose callbacks to fire. One of 'key_entered', 'key_exited', or 'key_moved'.\r\n     * @param key The key of the location for which to fire the callbacks.\r\n     * @param location The location as [latitude, longitude] pair\r\n     * @param distanceFromCenter The distance from the center or null.\r\n     */\r\n    GeoQuery.prototype._fireCallbacksForKey = function (eventType, key, location, distanceFromCenter) {\r\n        this._callbacks[eventType].forEach(function (callback) {\r\n            if (typeof location === 'undefined' || location === null) {\r\n                callback(key, null, null);\r\n            }\r\n            else {\r\n                callback(key, location, distanceFromCenter);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Fires each callback for the 'ready' event.\r\n     */\r\n    GeoQuery.prototype._fireReadyEventCallbacks = function () {\r\n        this._callbacks.ready.forEach(function (callback) {\r\n            callback();\r\n        });\r\n    };\r\n    /**\r\n     * Checks if this geohash is currently part of any of the geohash queries.\r\n     *\r\n     * @param geohash The geohash.\r\n     * @returns Returns true if the geohash is part of any of the current geohash queries.\r\n     */\r\n    GeoQuery.prototype._geohashInSomeQuery = function (geohash) {\r\n        var keys = Object.keys(this._currentGeohashesQueried);\r\n        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\r\n            var queryStr = keys_2[_i];\r\n            if (queryStr in this._currentGeohashesQueried) {\r\n                var query = this._stringToQuery(queryStr);\r\n                if (geohash >= query[0] && geohash <= query[1]) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Called once all geohash queries have received all child added events and fires the ready\r\n     * event if necessary.\r\n     */\r\n    GeoQuery.prototype._geohashQueryReadyCallback = function (queryStr) {\r\n        var index = this._outstandingGeohashReadyEvents.indexOf(queryStr);\r\n        if (index > -1) {\r\n            this._outstandingGeohashReadyEvents.splice(index, 1);\r\n        }\r\n        this._valueEventFired = (this._outstandingGeohashReadyEvents.length === 0);\r\n        // If all queries have been processed, fire the ready event\r\n        if (this._valueEventFired) {\r\n            this._fireReadyEventCallbacks();\r\n        }\r\n    };\r\n    /**\r\n     * Attaches listeners to Firebase which track when new geohashes are added within this query's\r\n     * bounding box.\r\n     */\r\n    GeoQuery.prototype._listenForNewGeohashes = function () {\r\n        var _this = this;\r\n        // Get the list of geohashes to query\r\n        var geohashesToQuery = geohashQueries(this._center, this._radius * 1000).map(this._queryToString);\r\n        // Filter out duplicate geohashes\r\n        geohashesToQuery = geohashesToQuery.filter(function (geohash, i) { return geohashesToQuery.indexOf(geohash) === i; });\r\n        // For all of the geohashes that we are already currently querying, check if they are still\r\n        // supposed to be queried. If so, don't re-query them. Otherwise, mark them to be un-queried\r\n        // next time we clean up the current geohashes queried dictionary.\r\n        var keys = Object.keys(this._currentGeohashesQueried);\r\n        keys.forEach(function (geohashQueryStr) {\r\n            var index = geohashesToQuery.indexOf(geohashQueryStr);\r\n            if (index === -1) {\r\n                _this._currentGeohashesQueried[geohashQueryStr].active = false;\r\n            }\r\n            else {\r\n                _this._currentGeohashesQueried[geohashQueryStr].active = true;\r\n                geohashesToQuery.splice(index, 1);\r\n            }\r\n        });\r\n        // If we are not already cleaning up the current geohashes queried and we have more than 25 of them,\r\n        // kick off a timeout to clean them up so we don't create an infinite number of unneeded queries.\r\n        if (this._geohashCleanupScheduled === false && Object.keys(this._currentGeohashesQueried).length > 25) {\r\n            this._geohashCleanupScheduled = true;\r\n            this._cleanUpCurrentGeohashesQueriedTimeout = setTimeout(this._cleanUpCurrentGeohashesQueried, 10);\r\n        }\r\n        // Keep track of which geohashes have been processed so we know when to fire the 'ready' event\r\n        this._outstandingGeohashReadyEvents = geohashesToQuery.slice();\r\n        // Loop through each geohash to query for and listen for new geohashes which have the same prefix.\r\n        // For every match, attach a value callback which will fire the appropriate events.\r\n        // Once every geohash to query is processed, fire the 'ready' event.\r\n        geohashesToQuery.forEach(function (toQueryStr) {\r\n            // decode the geohash query string\r\n            var query = _this._stringToQuery(toQueryStr);\r\n            // Create the Firebase query\r\n            var firebaseQuery = _this._firebaseRef.orderByChild('g').startAt(query[0]).endAt(query[1]);\r\n            // For every new matching geohash, determine if we should fire the 'key_entered' event\r\n            var childAddedCallback = firebaseQuery.on('child_added', function (a) { return _this._childAddedCallback(a); });\r\n            var childRemovedCallback = firebaseQuery.on('child_removed', function (a) { return _this._childRemovedCallback(a); });\r\n            var childChangedCallback = firebaseQuery.on('child_changed', function (a) { return _this._childChangedCallback(a); });\r\n            // Once the current geohash to query is processed, see if it is the last one to be processed\r\n            // and, if so, mark the value event as fired.\r\n            // Note that Firebase fires the 'value' event after every 'child_added' event fires.\r\n            var valueCallback = firebaseQuery.on('value', function () {\r\n                firebaseQuery.off('value', valueCallback);\r\n                _this._geohashQueryReadyCallback(toQueryStr);\r\n            });\r\n            // Add the geohash query to the current geohashes queried dictionary and save its state\r\n            _this._currentGeohashesQueried[toQueryStr] = {\r\n                active: true,\r\n                childAddedCallback: childAddedCallback,\r\n                childRemovedCallback: childRemovedCallback,\r\n                childChangedCallback: childChangedCallback,\r\n                valueCallback: valueCallback\r\n            };\r\n        });\r\n        // Based upon the algorithm to calculate geohashes, it's possible that no 'new'\r\n        // geohashes were queried even if the client updates the radius of the query.\r\n        // This results in no 'READY' event being fired after the .updateCriteria() call.\r\n        // Check to see if this is the case, and trigger the 'READY' event.\r\n        if (geohashesToQuery.length === 0) {\r\n            this._geohashQueryReadyCallback();\r\n        }\r\n    };\r\n    /**\r\n     * Encodes a query as a string for easier indexing and equality.\r\n     *\r\n     * @param query The query to encode.\r\n     * @returns The encoded query as string.\r\n     */\r\n    GeoQuery.prototype._queryToString = function (query) {\r\n        if (query.length !== 2) {\r\n            throw new Error('Not a valid geohash query: ' + query);\r\n        }\r\n        return query[0] + ':' + query[1];\r\n    };\r\n    /**\r\n     * Removes the location from the local state and fires any events if necessary.\r\n     *\r\n     * @param key The key to be removed.\r\n     * @param currentLocation The current location as [latitude, longitude] pair or null if removed.\r\n     */\r\n    GeoQuery.prototype._removeLocation = function (key, currentLocation) {\r\n        var locationDict = this._locationsTracked[key];\r\n        delete this._locationsTracked[key];\r\n        if (typeof locationDict !== 'undefined' && locationDict.isInQuery) {\r\n            var distanceFromCenter = (currentLocation) ? distance(currentLocation, this._center) : null;\r\n            this._fireCallbacksForKey('key_exited', key, currentLocation, distanceFromCenter);\r\n        }\r\n    };\r\n    /**\r\n     * Decodes a query string to a query\r\n     *\r\n     * @param str The encoded query.\r\n     * @returns The decoded query as a [start, end] pair.\r\n     */\r\n    GeoQuery.prototype._stringToQuery = function (str) {\r\n        var decoded = str.split(':');\r\n        if (decoded.length !== 2) {\r\n            throw new Error('Invalid internal state! Not a valid geohash query: ' + str);\r\n        }\r\n        return decoded;\r\n    };\r\n    /**\r\n     * Callback for any updates to locations. Will update the information about a key and fire any necessary\r\n     * events every time the key's location changes.\r\n     *\r\n     * When a key is removed from GeoFire or the query, this function will be called with null and performs\r\n     * any necessary cleanup.\r\n     *\r\n     * @param key The key of the geofire location.\r\n     * @param location The location as [latitude, longitude] pair.\r\n     */\r\n    GeoQuery.prototype._updateLocation = function (key, location) {\r\n        validateLocation(location);\r\n        // Get the key and location\r\n        var distanceFromCenter, isInQuery;\r\n        var wasInQuery = (key in this._locationsTracked) ? this._locationsTracked[key].isInQuery : false;\r\n        var oldLocation = (key in this._locationsTracked) ? this._locationsTracked[key].location : null;\r\n        // Determine if the location is within this query\r\n        distanceFromCenter = distance(location, this._center);\r\n        isInQuery = (distanceFromCenter <= this._radius);\r\n        // Add this location to the locations queried dictionary even if it is not within this query\r\n        this._locationsTracked[key] = {\r\n            location: location,\r\n            distanceFromCenter: distanceFromCenter,\r\n            isInQuery: isInQuery,\r\n            geohash: encodeGeohash(location)\r\n        };\r\n        // Fire the 'key_entered' event if the provided key has entered this query\r\n        if (isInQuery && !wasInQuery) {\r\n            this._fireCallbacksForKey('key_entered', key, location, distanceFromCenter);\r\n        }\r\n        else if (isInQuery && oldLocation !== null && (location[0] !== oldLocation[0] || location[1] !== oldLocation[1])) {\r\n            this._fireCallbacksForKey('key_moved', key, location, distanceFromCenter);\r\n        }\r\n        else if (!isInQuery && wasInQuery) {\r\n            this._fireCallbacksForKey('key_exited', key, location, distanceFromCenter);\r\n        }\r\n    };\r\n    return GeoQuery;\r\n}());\r\nexport { GeoQuery };\r\n","dts":{"name":"/home/laboratoria/Downloads/geofire-js-master/geoFire/geoQuery.d.ts","text":"import * as firebase from 'firebase';\r\nimport { GeoCallbackRegistration } from './geoCallbackRegistration';\r\nimport { QueryCriteria } from './interfaces';\r\n/**\r\n * Creates a GeoQuery instance.\r\n */\r\nexport declare class GeoQuery {\r\n    private _firebaseRef;\r\n    private _callbacks;\r\n    private _cancelled;\r\n    private _center;\r\n    private _currentGeohashesQueried;\r\n    private _locationsTracked;\r\n    private _radius;\r\n    private _valueEventFired;\r\n    private _outstandingGeohashReadyEvents;\r\n    private _geohashCleanupScheduled;\r\n    private _cleanUpCurrentGeohashesQueriedInterval;\r\n    private _cleanUpCurrentGeohashesQueriedTimeout;\r\n    /**\r\n     * @param _firebaseRef A Firebase reference where the GeoFire data will be stored.\r\n     * @param queryCriteria The criteria which specifies the query's center and radius.\r\n     */\r\n    constructor(_firebaseRef: firebase.database.Reference, queryCriteria: QueryCriteria);\r\n    /********************/\r\n    /********************/\r\n    /**\r\n     * Terminates this query so that it no longer sends location updates. All callbacks attached to this\r\n     * query via on() will be cancelled. This query can no longer be used in the future.\r\n     */\r\n    cancel(): void;\r\n    /**\r\n     * Returns the location signifying the center of this query.\r\n     *\r\n     * @returns The [latitude, longitude] pair signifying the center of this query.\r\n     */\r\n    center(): number[];\r\n    /**\r\n     * Attaches a callback to this query which will be run when the provided eventType fires. Valid eventType\r\n     * values are 'ready', 'key_entered', 'key_exited', and 'key_moved'. The ready event callback is passed no\r\n     * parameters. All other callbacks will be passed three parameters: (1) the location's key, (2) the location's\r\n     * [latitude, longitude] pair, and (3) the distance, in kilometers, from the location to this query's center\r\n     *\r\n     * 'ready' is used to signify that this query has loaded its initial state and is up-to-date with its corresponding\r\n     * GeoFire instance. 'ready' fires when this query has loaded all of the initial data from GeoFire and fired all\r\n     * other events for that data. It also fires every time updateCriteria() is called, after all other events have\r\n     * fired for the updated query.\r\n     *\r\n     * 'key_entered' fires when a key enters this query. This can happen when a key moves from a location outside of\r\n     * this query to one inside of it or when a key is written to GeoFire for the first time and it falls within\r\n     * this query.\r\n     *\r\n     * 'key_exited' fires when a key moves from a location inside of this query to one outside of it. If the key was\r\n     * entirely removed from GeoFire, both the location and distance passed to the callback will be null.\r\n     *\r\n     * 'key_moved' fires when a key which is already in this query moves to another location inside of it.\r\n     *\r\n     * Returns a GeoCallbackRegistration which can be used to cancel the callback. You can add as many callbacks\r\n     * as you would like for the same eventType by repeatedly calling on(). Each one will get called when its\r\n     * corresponding eventType fires. Each callback must be cancelled individually.\r\n     *\r\n     * @param eventType The event type for which to attach the callback. One of 'ready', 'key_entered',\r\n     * 'key_exited', or 'key_moved'.\r\n     * @param callback Callback function to be called when an event of type eventType fires.\r\n     * @returns A callback registration which can be used to cancel the provided callback.\r\n     */\r\n    on(eventType: string, callback: Function): GeoCallbackRegistration;\r\n    /**\r\n     * Returns the radius of this query, in kilometers.\r\n     *\r\n     * @returns The radius of this query, in kilometers.\r\n     */\r\n    radius(): number;\r\n    /**\r\n     * Updates the criteria for this query.\r\n     *\r\n     * @param newQueryCriteria The criteria which specifies the query's center and radius.\r\n     */\r\n    updateCriteria(newQueryCriteria: QueryCriteria): void;\r\n    /*********************/\r\n    /*********************/\r\n    /**\r\n     * Turns off all callbacks for the provide geohash query.\r\n     *\r\n     * @param query The geohash query.\r\n     * @param queryState An object storing the current state of the query.\r\n     */\r\n    private _cancelGeohashQuery;\r\n    /**\r\n     * Callback for child added events.\r\n     *\r\n     * @param locationDataSnapshot A snapshot of the data stored for this location.\r\n     */\r\n    private _childAddedCallback;\r\n    /**\r\n     * Callback for child changed events\r\n     *\r\n     * @param locationDataSnapshot A snapshot of the data stored for this location.\r\n     */\r\n    private _childChangedCallback;\r\n    /**\r\n     * Callback for child removed events\r\n     *\r\n     * @param locationDataSnapshot A snapshot of the data stored for this location.\r\n     */\r\n    private _childRemovedCallback;\r\n    /**\r\n     * Removes unnecessary Firebase queries which are currently being queried.\r\n     */\r\n    private _cleanUpCurrentGeohashesQueried;\r\n    /**\r\n     * Fires each callback for the provided eventType, passing it provided key's data.\r\n     *\r\n     * @param eventType The event type whose callbacks to fire. One of 'key_entered', 'key_exited', or 'key_moved'.\r\n     * @param key The key of the location for which to fire the callbacks.\r\n     * @param location The location as [latitude, longitude] pair\r\n     * @param distanceFromCenter The distance from the center or null.\r\n     */\r\n    private _fireCallbacksForKey;\r\n    /**\r\n     * Fires each callback for the 'ready' event.\r\n     */\r\n    private _fireReadyEventCallbacks;\r\n    /**\r\n     * Checks if this geohash is currently part of any of the geohash queries.\r\n     *\r\n     * @param geohash The geohash.\r\n     * @returns Returns true if the geohash is part of any of the current geohash queries.\r\n     */\r\n    private _geohashInSomeQuery;\r\n    /**\r\n     * Called once all geohash queries have received all child added events and fires the ready\r\n     * event if necessary.\r\n     */\r\n    private _geohashQueryReadyCallback;\r\n    /**\r\n     * Attaches listeners to Firebase which track when new geohashes are added within this query's\r\n     * bounding box.\r\n     */\r\n    private _listenForNewGeohashes;\r\n    /**\r\n     * Encodes a query as a string for easier indexing and equality.\r\n     *\r\n     * @param query The query to encode.\r\n     * @returns The encoded query as string.\r\n     */\r\n    private _queryToString;\r\n    /**\r\n     * Removes the location from the local state and fires any events if necessary.\r\n     *\r\n     * @param key The key to be removed.\r\n     * @param currentLocation The current location as [latitude, longitude] pair or null if removed.\r\n     */\r\n    private _removeLocation;\r\n    /**\r\n     * Decodes a query string to a query\r\n     *\r\n     * @param str The encoded query.\r\n     * @returns The decoded query as a [start, end] pair.\r\n     */\r\n    private _stringToQuery;\r\n    /**\r\n     * Callback for any updates to locations. Will update the information about a key and fire any necessary\r\n     * events every time the key's location changes.\r\n     *\r\n     * When a key is removed from GeoFire or the query, this function will be called with null and performs\r\n     * any necessary cleanup.\r\n     *\r\n     * @param key The key of the geofire location.\r\n     * @param location The location as [latitude, longitude] pair.\r\n     */\r\n    private _updateLocation;\r\n}\r\n"}}
